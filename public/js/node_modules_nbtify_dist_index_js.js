"use strict";
(self["webpackChunkskyblock_profile_viewer"] = self["webpackChunkskyblock_profile_viewer"] || []).push([["node_modules_nbtify_dist_index_js"],{

/***/ "./node_modules/mutf-8/dist/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/mutf-8/dist/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MUtf8Decoder: () => (/* binding */ MUtf8Decoder),
/* harmony export */   MUtf8Encoder: () => (/* binding */ MUtf8Encoder)
/* harmony export */ });
// SPDX-License-Identifier: MIT
/**
 * The decoder for Modified UTF-8.
 *
 * @example
 * ```ts
 * const src = new Uint8Array([
 *   0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0xe4, 0xb8,
 *   0x96, 0xe7, 0x95, 0x8c, 0x21,
 * ]);
 * const decoder = new MUtf8Decoder();
 * const text = decoder.decode(src);
 * // Hello 世界!
 * ```
 *
 * @see {@link https://encoding.spec.whatwg.org/#interface-textdecoder}
 */
class MUtf8Decoder {
    #fatal;
    #ignoreBOM;
    #leavings;
    /**
     * @returns Always `"mutf-8"`.
     */
    get encoding() {
        return "mutf-8";
    }
    /**
     * @returns `true` if error mode is fatal, otherwise `false`.
     */
    get fatal() {
        return this.#fatal;
    }
    /**
     * @returns Whether to ignore the BOM or not.
     */
    get ignoreBOM() {
        return this.#ignoreBOM;
    }
    /**
     * @param label   - The label of the decoder. Must be `"mutf-8"` or `"mutf8"`.
     * @param options - The options for the decoder.
     * @throws `RangeError` If the `label` is an invalid value.
     */
    constructor(label = "mutf-8", options = {}) {
        const normalizedLabel = label.toLowerCase();
        if (normalizedLabel !== "mutf-8" && normalizedLabel !== "mutf8") {
            throw new RangeError(`MUtf8Decoder.constructor: '${label}' is not supported.`);
        }
        this.#fatal = options.fatal ?? false;
        this.#ignoreBOM = options.ignoreBOM ?? false;
    }
    /**
     * Decodes the specified bytes into a string.
     *
     * @param input   - The bytes to be decoded.
     * @param options - The options for decoding.
     * @returns The resultant string after decoding.
     * @throws `TypeError` If {@link fatal} is `true` and the `input` contains invalid bytes.
     */
    decode(input, options = {}) {
        const stream = options.stream ?? false;
        const buf = this.#toBinary(input);
        const length = buf.length;
        const result = [];
        let p = 0;
        while (p < length) {
            const b1 = buf[p++];
            if (!(b1 & 0x80) && b1 !== 0) {
                // U+0001-007F
                result.push(String.fromCharCode(b1));
            }
            else if ((b1 & 0xe0) === 0xc0) {
                // U+0000, U+0080-07FF
                if (length <= p) {
                    if (stream) {
                        this.#leavings = buf.slice(p - 1);
                        break;
                    }
                    result.push(this.#handleError());
                    continue;
                }
                const b2 = buf[p++];
                if ((b2 & 0xc0) !== 0x80) {
                    result.push(this.#handleError());
                    p--;
                    continue;
                }
                result.push(String.fromCharCode(((b1 & 0x1f) << 6) | (b2 & 0x3f)));
            }
            else if ((b1 & 0xf0) === 0xe0) {
                // U+0800-FFFF
                if (length <= p + 1) {
                    if (stream) {
                        this.#leavings = buf.slice(p - 1);
                        break;
                    }
                    result.push(this.#handleError());
                    continue;
                }
                const b2 = buf[p++];
                if ((b2 & 0xc0) !== 0x80) {
                    result.push(this.#handleError());
                    p--;
                    continue;
                }
                const b3 = buf[p++];
                if ((b3 & 0xc0) !== 0x80) {
                    result.push(this.#handleError());
                    p -= 2;
                    continue;
                }
                if (p === 3 && b1 === 0xef && b2 === 0xbb && b3 === 0xbf && !this.ignoreBOM) {
                    // skip BOM `EF BB BF`
                    continue;
                }
                result.push(String.fromCharCode(((b1 & 0x0f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f)));
            }
            else {
                result.push(this.#handleError());
            }
        }
        return result.join("");
    }
    #toBinary(input) {
        let bin;
        if (input instanceof Uint8Array) {
            bin = input;
        }
        else {
            bin = new Uint8Array("buffer" in input ? input.buffer : input);
        }
        if (!this.#leavings) {
            return bin;
        }
        const combined = new Uint8Array(this.#leavings.length + bin.length);
        combined.set(this.#leavings, 0);
        combined.set(bin, this.#leavings.length);
        this.#leavings = undefined;
        return combined;
    }
    #handleError() {
        if (this.fatal) {
            throw new TypeError("MUtf8Decoder.decode: Decoding failed.");
        }
        return "\ufffd";
    }
}
/**
 * The encoder for Modified UTF-8.
 *
 * @example
 * ```ts
 * const encoder = new MUtf8Encoder();
 * const code = encoder.encode("Hello 世界!");
 * // Uint8Array [
 * //   0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0xe4, 0xb8,
 * //   0x96, 0xe7, 0x95, 0x8c, 0x21,
 * // ]
 * ```
 *
 * @see {@link https://encoding.spec.whatwg.org/#interface-textencoder}
 */
class MUtf8Encoder {
    /**
     * @returns Always `"mutf-8"`.
     */
    get encoding() {
        return "mutf-8";
    }
    /**
     * Encodes the specified string in Modified UTF-8.
     *
     * @param input - The string to be encoded.
     * @returns The resultant bytes.
     */
    encode(input = "") {
        const bin = [];
        for (const c of input) {
            // biome-ignore lint/style/noNonNullAssertion: `c` is always a non-empty string.
            const code = c.codePointAt(0);
            if (0x0001 <= code && code <= 0x007f) {
                bin.push(code);
            }
            else if (code <= 0x07ff) {
                bin.push(0xc0 | (code >>> 6));
                bin.push(0x80 | (0x3f & code));
            }
            else if (code <= 0xffff) {
                bin.push(0xe0 | (code >>> 12));
                bin.push(0x80 | (0x3f & (code >>> 6)));
                bin.push(0x80 | (0x3f & code));
            }
            else {
                bin.push(0xed);
                bin.push(0xa0 | ((code >>> 16) - 1));
                bin.push(0x80 | (0x3f & (code >>> 10)));
                bin.push(0xed);
                bin.push(0xb0 | (0x0f & (code >>> 6)));
                bin.push(0x80 | (0x3f & code));
            }
        }
        return new Uint8Array(bin);
    }
    /**
     * Encodes the specified string in Modified UTF-8 and stores the result in the specified array.
     *
     * @param source      - The string to be encoded.
     * @param destination - The array to store the encoded bytes.
     * @returns The progress of the encoding operation.
     */
    encodeInto(source, destination) {
        const destLen = destination.length;
        let i = 0;
        let read = 0;
        for (const c of source) {
            // biome-ignore lint/style/noNonNullAssertion: `c` is always a non-empty string.
            const code = c.codePointAt(0);
            if (0x0001 <= code && code <= 0x007f) {
                if (destLen <= i)
                    break;
                destination[i++] = code;
            }
            else if (code <= 0x07ff) {
                if (destLen <= i + 1)
                    break;
                destination[i++] = 0xc0 | (code >>> 6);
                destination[i++] = 0x80 | (0x3f & code);
            }
            else if (code <= 0xffff) {
                if (destLen <= i + 2)
                    break;
                destination[i++] = 0xe0 | (code >>> 12);
                destination[i++] = 0x80 | (0x3f & (code >>> 6));
                destination[i++] = 0x80 | (0x3f & code);
            }
            else {
                if (destLen <= i + 5)
                    break;
                destination[i++] = 0xed;
                destination[i++] = 0xa0 | ((code >>> 16) - 1);
                destination[i++] = 0x80 | (0x3f & (code >>> 10));
                destination[i++] = 0xed;
                destination[i++] = 0xb0 | (0x0f & (code >>> 6));
                destination[i++] = 0x80 | (0x3f & code);
                read++;
            }
            read++;
        }
        return { read, written: i };
    }
}


/***/ }),

/***/ "./node_modules/nbtify/dist/compression.js":
/*!*************************************************!*\
  !*** ./node_modules/nbtify/dist/compression.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compress: () => (/* binding */ compress),
/* harmony export */   decompress: () => (/* binding */ decompress)
/* harmony export */ });
/**
 * Compresses a Uint8Array using a specific compression format.
*/
async function compress(data, format) {
    const compressionStream = new CompressionStream(format);
    return pipeThroughCompressionStream(data, compressionStream);
}
/**
 * Decompresses a Uint8Array using a specific decompression format.
*/
async function decompress(data, format) {
    const decompressionStream = new DecompressionStream(format);
    return pipeThroughCompressionStream(data, decompressionStream);
}
async function pipeThroughCompressionStream(data, { readable, writable }) {
    const writer = writable.getWriter();
    writer.write(data).catch(() => { });
    writer.close().catch(() => { });
    const chunks = [];
    let byteLength = 0;
    const iterator = readableStreamToAsyncIterable(readable);
    for await (const chunk of iterator) {
        chunks.push(chunk);
        byteLength += chunk.byteLength;
    }
    const result = new Uint8Array(byteLength);
    let byteOffset = 0;
    for (const chunk of chunks) {
        result.set(chunk, byteOffset);
        byteOffset += chunk.byteLength;
    }
    return result;
}
function readableStreamToAsyncIterable(readable) {
    if (typeof readable[Symbol.asyncIterator] === "undefined") {
        return readableStreamToAsyncGenerator(readable);
    }
    return readable;
}
async function* readableStreamToAsyncGenerator(readable) {
    const reader = readable.getReader();
    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done)
                return;
            yield value;
        }
    }
    finally {
        reader.releaseLock();
    }
}
//# sourceMappingURL=compression.js.map

/***/ }),

/***/ "./node_modules/nbtify/dist/format.js":
/*!********************************************!*\
  !*** ./node_modules/nbtify/dist/format.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NBTData: () => (/* binding */ NBTData)
/* harmony export */ });
/**
 * A container which maintains how a given NBT object is formatted.
*/
class NBTData {
    data;
    rootName;
    endian;
    compression;
    bedrockLevel;
    #byteOffset = null;
    constructor(data, options = {}) {
        if (data instanceof NBTData) {
            if (options.rootName === undefined) {
                options.rootName = data.rootName;
            }
            if (options.endian === undefined) {
                options.endian = data.endian;
            }
            if (options.compression === undefined) {
                options.compression = data.compression;
            }
            if (options.bedrockLevel === undefined) {
                options.bedrockLevel = data.bedrockLevel;
            }
            data = data.data;
        }
        const { rootName = "", endian = "big", compression = null, bedrockLevel = false } = options;
        this.data = data;
        this.rootName = rootName;
        this.endian = endian;
        this.compression = compression;
        this.bedrockLevel = bedrockLevel;
    }
    get byteOffset() {
        return this.#byteOffset;
    }
    /**
     * @internal
     */
    set byteOffset(value) {
        this.#byteOffset = value;
    }
    get [Symbol.toStringTag]() {
        return "NBTData";
    }
}
//# sourceMappingURL=format.js.map

/***/ }),

/***/ "./node_modules/nbtify/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/nbtify/dist/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Float32: () => (/* reexport safe */ _primitive_js__WEBPACK_IMPORTED_MODULE_6__.Float32),
/* harmony export */   Int16: () => (/* reexport safe */ _primitive_js__WEBPACK_IMPORTED_MODULE_6__.Int16),
/* harmony export */   Int32: () => (/* reexport safe */ _primitive_js__WEBPACK_IMPORTED_MODULE_6__.Int32),
/* harmony export */   Int8: () => (/* reexport safe */ _primitive_js__WEBPACK_IMPORTED_MODULE_6__.Int8),
/* harmony export */   NBTData: () => (/* reexport safe */ _format_js__WEBPACK_IMPORTED_MODULE_4__.NBTData),
/* harmony export */   TAG: () => (/* reexport safe */ _tag_js__WEBPACK_IMPORTED_MODULE_5__.TAG),
/* harmony export */   TAG_TYPE: () => (/* reexport safe */ _tag_js__WEBPACK_IMPORTED_MODULE_5__.TAG_TYPE),
/* harmony export */   compress: () => (/* reexport safe */ _compression_js__WEBPACK_IMPORTED_MODULE_7__.compress),
/* harmony export */   decompress: () => (/* reexport safe */ _compression_js__WEBPACK_IMPORTED_MODULE_7__.decompress),
/* harmony export */   getTagType: () => (/* reexport safe */ _tag_js__WEBPACK_IMPORTED_MODULE_5__.getTagType),
/* harmony export */   isTag: () => (/* reexport safe */ _tag_js__WEBPACK_IMPORTED_MODULE_5__.isTag),
/* harmony export */   isTagType: () => (/* reexport safe */ _tag_js__WEBPACK_IMPORTED_MODULE_5__.isTagType),
/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_2__.parse),
/* harmony export */   read: () => (/* reexport safe */ _read_js__WEBPACK_IMPORTED_MODULE_0__.read),
/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_3__.stringify),
/* harmony export */   write: () => (/* reexport safe */ _write_js__WEBPACK_IMPORTED_MODULE_1__.write)
/* harmony export */ });
/* harmony import */ var _read_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./read.js */ "./node_modules/nbtify/dist/read.js");
/* harmony import */ var _write_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./write.js */ "./node_modules/nbtify/dist/write.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse.js */ "./node_modules/nbtify/dist/parse.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/nbtify/dist/stringify.js");
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./format.js */ "./node_modules/nbtify/dist/format.js");
/* harmony import */ var _tag_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tag.js */ "./node_modules/nbtify/dist/tag.js");
/* harmony import */ var _primitive_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./primitive.js */ "./node_modules/nbtify/dist/primitive.js");
/* harmony import */ var _compression_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./compression.js */ "./node_modules/nbtify/dist/compression.js");








//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/nbtify/dist/parse.js":
/*!*******************************************!*\
  !*** ./node_modules/nbtify/dist/parse.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var _primitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./primitive.js */ "./node_modules/nbtify/dist/primitive.js");
/* harmony import */ var _tag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tag.js */ "./node_modules/nbtify/dist/tag.js");


const UNQUOTED_STRING_PATTERN = /^[0-9A-Za-z.+_-]+$/;
/**
 * Converts an SNBT string into an NBT object.
*/
function parse(data) {
    if (typeof data !== "string") {
        data;
        throw new TypeError("First parameter must be a string");
    }
    return new SNBTReader().parseRoot(data);
}
class SNBTReader {
    #i = 0;
    #index = 0;
    #peek(data, index, byteOffset = index) {
        const value = data[byteOffset];
        if (value === undefined) {
            throw this.#unexpectedEnd();
        }
        return value;
    }
    #unexpectedEnd() {
        return new Error("Unexpected end");
    }
    #unexpectedChar(data, index, i) {
        if (i == null) {
            i = index;
        }
        return new Error(`Unexpected character ${this.#peek(data, index)} at position ${index}`);
    }
    #skipWhitespace(data) {
        while (this.#index < data.length) {
            if (!/ |\t|\r/.test(this.#peek(data, this.#index)) && this.#peek(data, this.#index) != "\n")
                return;
            this.#index += 1;
        }
    }
    parseRoot(data) {
        this.#skipWhitespace(data);
        this.#i = this.#index;
        switch (this.#peek(data, this.#index)) {
            case "{": {
                this.#index++;
                return this.#parseCompound(data);
            }
            case "[": {
                this.#index++;
                const list = this.#parseList(data, "[root]");
                const type = (0,_tag_js__WEBPACK_IMPORTED_MODULE_0__.getTagType)(list);
                if (type !== _tag_js__WEBPACK_IMPORTED_MODULE_0__.TAG.LIST)
                    break;
                return list;
            }
        }
        throw new Error("Encountered unexpected Root tag type, must be either a List or Compound tag");
    }
    #parseTag(data, key) {
        this.#skipWhitespace(data);
        this.#i = this.#index;
        switch (this.#peek(data, this.#index)) {
            case "{": {
                this.#index++;
                return this.#parseCompound(data);
            }
            case "[": return (this.#index++, this.#parseList(data, key));
            case '"':
            case "'": return this.#parseQuotedString(data);
            default: {
                if (/^(true)$/.test(data.slice(this.#i, this.#index + 4)) ||
                    /^(false)$/.test(data.slice(this.#i, this.#index + 5))) {
                    return (this.#parseUnquotedString(data) === "true");
                }
                const value = this.#parseNumber(data);
                if (value != null && (this.#index == data.length || !UNQUOTED_STRING_PATTERN.test(this.#peek(data, this.#index)))) {
                    return value;
                }
                return (data.slice(this.#i, this.#index) + this.#parseUnquotedString(data));
            }
        }
    }
    #parseNumber(data) {
        if (!"-0123456789".includes(this.#peek(data, this.#index)))
            return null;
        this.#i = this.#index++;
        let hasFloatingPoint = false;
        while (this.#index < data.length) {
            const char = this.#peek(data, this.#index);
            this.#index++;
            if ("0123456789e-+".includes(char))
                continue;
            switch (char.toLowerCase()) {
                case ".": {
                    if (hasFloatingPoint) {
                        this.#index--;
                        return null;
                    }
                    hasFloatingPoint = true;
                    break;
                }
                case "f": return new _primitive_js__WEBPACK_IMPORTED_MODULE_1__.Float32(Number(data.slice(this.#i, this.#index - 1)));
                case "d": return Number(data.slice(this.#i, this.#index - 1));
                case "b": return new _primitive_js__WEBPACK_IMPORTED_MODULE_1__.Int8(Number(data.slice(this.#i, this.#index - 1)));
                case "s": return new _primitive_js__WEBPACK_IMPORTED_MODULE_1__.Int16(Number(data.slice(this.#i, this.#index - 1)));
                case "l": return BigInt(data.slice(this.#i, this.#index - 1));
                default: {
                    if (hasFloatingPoint) {
                        return Number(data.slice(this.#i, --this.#index));
                    }
                    else {
                        return new _primitive_js__WEBPACK_IMPORTED_MODULE_1__.Int32(Number(data.slice(this.#i, --this.#index)));
                    }
                }
            }
        }
        if (hasFloatingPoint) {
            return Number(data.slice(this.#i, this.#index));
        }
        else {
            return new _primitive_js__WEBPACK_IMPORTED_MODULE_1__.Int32(Number(data.slice(this.#i, this.#index)));
        }
    }
    #parseString(data) {
        if (this.#peek(data, this.#index) == '"' || this.#peek(data, this.#index) == "'") {
            return this.#parseQuotedString(data);
        }
        else {
            return this.#parseUnquotedString(data);
        }
    }
    #parseUnquotedString(data) {
        this.#i = this.#index;
        while (this.#index < data.length) {
            if (!UNQUOTED_STRING_PATTERN.test(this.#peek(data, this.#index)))
                break;
            this.#index++;
        }
        if (this.#index - this.#i == 0) {
            if (this.#index == data.length) {
                throw this.#unexpectedEnd();
            }
            else {
                throw this.#unexpectedChar(data, this.#index);
            }
        }
        return data.slice(this.#i, this.#index);
    }
    #parseQuotedString(data) {
        const quoteChar = this.#peek(data, this.#index);
        // i = 
        ++this.#index;
        let string = "";
        while (this.#index < data.length) {
            let char = this.#peek(data, this.#index++);
            if (char === "\\") {
                char = `\\${this.#peek(data, this.#index++)}`;
            }
            if (char === quoteChar) {
                return string;
            }
            string += this.#unescapeString(char);
        }
        throw this.#unexpectedEnd();
    }
    #unescapeString(value) {
        return value
            .replaceAll("\\\\", "\\")
            .replaceAll("\\\"", "\"")
            .replaceAll("\\'", "'")
            .replaceAll("\\0", "\0")
            .replaceAll("\\b", "\b")
            .replaceAll("\\f", "\f")
            .replaceAll("\\n", "\n")
            .replaceAll("\\r", "\r")
            .replaceAll("\\t", "\t");
    }
    #skipCommas(data, isFirst, end) {
        this.#skipWhitespace(data);
        if (this.#peek(data, this.#index) == ",") {
            if (isFirst) {
                throw this.#unexpectedChar(data, this.#index);
            }
            else {
                this.#index++;
                this.#skipWhitespace(data);
            }
        }
        else if (!isFirst && this.#peek(data, this.#index) != end) {
            throw this.#unexpectedChar(data, this.#index);
        }
    }
    #parseArray(data, type) {
        const array = [];
        while (this.#index < data.length) {
            this.#skipCommas(data, array.length == 0, "]");
            if (this.#peek(data, this.#index) == "]") {
                this.#index++;
                switch (type) {
                    case "B": return Int8Array.from(array.map(v => Number(v)));
                    case "I": return Int32Array.from(array.map(v => Number(v)));
                    case "L": return BigInt64Array.from(array.map(v => BigInt(v)));
                }
            }
            this.#i = this.#index;
            if (this.#peek(data, this.#index) == "-") {
                this.#index++;
            }
            while (this.#index < data.length) {
                if (!"0123456789".includes(this.#peek(data, this.#index)))
                    break;
                this.#index++;
            }
            const prefix = (type === "B") ? "b" : (type === "L") ? "l" : "";
            if (this.#peek(data, this.#index) == prefix) {
                this.#index++;
            }
            if (this.#index - this.#i == 0) {
                throw this.#unexpectedChar(data, this.#index);
            }
            if (UNQUOTED_STRING_PATTERN.test(this.#peek(data, this.#index))) {
                throw this.#unexpectedChar(data, this.#index);
            }
            array.push(data.slice(this.#i, this.#index - ((type !== "I") ? 1 : 0)));
        }
        throw this.#unexpectedEnd();
    }
    #parseList(data, key) {
        const prefix = this.#peek(data, this.#index).toUpperCase();
        if ("BIL".includes(prefix) && data[this.#index + 1] == ";") {
            return this.#parseArray(data, this.#peek(data, (this.#index += 2) - 2).toUpperCase());
        }
        const array = [];
        let type;
        while (this.#index < data.length) {
            this.#skipWhitespace(data);
            if (this.#peek(data, this.#index) == ",") {
                if (array.length == 0) {
                    throw this.#unexpectedChar(data, this.#index);
                }
                else {
                    this.#index++;
                    this.#skipWhitespace(data);
                }
            }
            else if (array.length > 0 && this.#peek(data, this.#index) != "]") {
                throw this.#unexpectedChar(data, this.#index - 1);
            }
            if (this.#peek(data, this.#index) == "]") {
                this.#index++;
                return array;
            }
            const entry = this.#parseTag(data, key);
            if (type === undefined) {
                type = (0,_tag_js__WEBPACK_IMPORTED_MODULE_0__.getTagType)(entry);
            }
            if ((0,_tag_js__WEBPACK_IMPORTED_MODULE_0__.getTagType)(entry) !== type) {
                throw new TypeError(`Encountered unexpected item type '${(0,_tag_js__WEBPACK_IMPORTED_MODULE_0__.getTagType)(entry)}' in List '${key}' at index ${array.length}, expected item type '${type}'. All tags in a List tag must be of the same type`);
            }
            array.push(entry);
        }
        throw this.#unexpectedEnd();
    }
    #parseCompound(data) {
        const value = {};
        let first = true;
        while (true) {
            this.#skipCommas(data, first, "}");
            first = false;
            if (this.#peek(data, this.#index) == "}") {
                this.#index++;
                return value;
            }
            const key = this.#parseString(data);
            this.#skipWhitespace(data);
            if (data[this.#index++] != ":") {
                throw this.#unexpectedChar(data, this.#index);
            }
            value[key] = this.#parseTag(data, key);
        }
    }
}
//# sourceMappingURL=parse.js.map

/***/ }),

/***/ "./node_modules/nbtify/dist/primitive.js":
/*!***********************************************!*\
  !*** ./node_modules/nbtify/dist/primitive.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Float32: () => (/* binding */ Float32),
/* harmony export */   Int16: () => (/* binding */ Int16),
/* harmony export */   Int32: () => (/* binding */ Int32),
/* harmony export */   Int8: () => (/* binding */ Int8)
/* harmony export */ });
const CustomInspect = Symbol.for("nodejs.util.inspect.custom");
class Int8 extends Number {
    constructor(value) {
        super(value << 24 >> 24);
    }
    valueOf() {
        return super.valueOf();
    }
    get [Symbol.toStringTag]() {
        return "Int8";
    }
    /**
     * @internal
    */
    get [CustomInspect]() {
        return (_, { stylize }) => stylize(`${this.valueOf()}b`, "number");
    }
}
class Int16 extends Number {
    constructor(value) {
        super(value << 16 >> 16);
    }
    valueOf() {
        return super.valueOf();
    }
    get [Symbol.toStringTag]() {
        return "Int16";
    }
    /**
     * @internal
    */
    get [CustomInspect]() {
        return (_, { stylize }) => stylize(`${this.valueOf()}s`, "number");
    }
}
class Int32 extends Number {
    constructor(value) {
        super(value | 0);
    }
    valueOf() {
        return super.valueOf();
    }
    get [Symbol.toStringTag]() {
        return "Int32";
    }
    /**
     * @internal
    */
    get [CustomInspect]() {
        return () => this.valueOf();
    }
}
class Float32 extends Number {
    constructor(value) {
        super(value);
    }
    valueOf() {
        return super.valueOf();
    }
    get [Symbol.toStringTag]() {
        return "Float32";
    }
    /**
     * @internal
    */
    get [CustomInspect]() {
        return (_, { stylize }) => stylize(`${this.valueOf()}f`, "number");
    }
}
//# sourceMappingURL=primitive.js.map

/***/ }),

/***/ "./node_modules/nbtify/dist/read.js":
/*!******************************************!*\
  !*** ./node_modules/nbtify/dist/read.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   read: () => (/* binding */ read)
/* harmony export */ });
/* harmony import */ var mutf_8__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mutf-8 */ "./node_modules/mutf-8/dist/index.mjs");
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./format.js */ "./node_modules/nbtify/dist/format.js");
/* harmony import */ var _primitive_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./primitive.js */ "./node_modules/nbtify/dist/primitive.js");
/* harmony import */ var _tag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tag.js */ "./node_modules/nbtify/dist/tag.js");
/* harmony import */ var _compression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compression.js */ "./node_modules/nbtify/dist/compression.js");





/**
 * Converts an NBT buffer into an NBT object. Accepts an endian type, compression format, and file headers to read the data with.
 *
 * If a format option isn't specified, the function will attempt reading the data using all options until it either throws or returns successfully.
*/
async function read(data, options = {}) {
    if (data instanceof Blob) {
        data = await data.arrayBuffer();
    }
    if (!("byteOffset" in data)) {
        data = new Uint8Array(data);
    }
    if (!(data instanceof Uint8Array)) {
        data;
        throw new TypeError("First parameter must be a Uint8Array, ArrayBuffer, SharedArrayBuffer, or Blob");
    }
    const reader = new NBTReader(data, options.endian !== "big", options.endian === "little-varint");
    let { rootName, endian, compression, bedrockLevel, strict = true } = options;
    if (rootName !== undefined && typeof rootName !== "boolean" && typeof rootName !== "string" && rootName !== null) {
        rootName;
        throw new TypeError("Root Name option must be a boolean, string, or null");
    }
    if (endian !== undefined && endian !== "big" && endian !== "little" && endian !== "little-varint") {
        endian;
        throw new TypeError("Endian option must be a valid endian type");
    }
    if (compression !== undefined && compression !== "deflate" && compression !== "deflate-raw" && compression !== "gzip" && compression !== null) {
        compression;
        throw new TypeError("Compression option must be a valid compression type");
    }
    if (bedrockLevel !== undefined && typeof bedrockLevel !== "boolean" && typeof bedrockLevel !== "number" && bedrockLevel !== null) {
        bedrockLevel;
        throw new TypeError("Bedrock Level option must be a boolean, number, or null");
    }
    if (typeof strict !== "boolean") {
        strict;
        throw new TypeError("Strict option must be a boolean");
    }
    compression: if (compression === undefined) {
        switch (true) {
            case reader.hasGzipHeader():
                compression = "gzip";
                break compression;
            case reader.hasZlibHeader():
                compression = "deflate";
                break compression;
        }
        try {
            return await read(data, { ...options, compression: null });
        }
        catch (error) {
            try {
                return await read(data, { ...options, compression: "deflate-raw" });
            }
            catch {
                throw error;
            }
        }
    }
    compression;
    if (endian === undefined) {
        try {
            return await read(data, { ...options, endian: "big" });
        }
        catch (error) {
            try {
                return await read(data, { ...options, endian: "little" });
            }
            catch {
                try {
                    return await read(data, { ...options, endian: "little-varint" });
                }
                catch {
                    throw error;
                }
            }
        }
    }
    endian;
    if (rootName === undefined) {
        try {
            return await read(data, { ...options, rootName: true });
        }
        catch (error) {
            try {
                return await read(data, { ...options, rootName: false });
            }
            catch {
                throw error;
            }
        }
    }
    rootName;
    if (compression !== null) {
        data = await (0,_compression_js__WEBPACK_IMPORTED_MODULE_0__.decompress)(data, compression);
    }
    if (bedrockLevel === undefined) {
        bedrockLevel = reader.hasBedrockLevelHeader(endian);
    }
    return reader.readRoot({ rootName, endian, compression, bedrockLevel, strict });
}
class NBTReader {
    #byteOffset = 0;
    #data;
    #view;
    #littleEndian;
    #varint;
    #decoder = new mutf_8__WEBPACK_IMPORTED_MODULE_1__.MUtf8Decoder();
    constructor(data, littleEndian, varint) {
        this.#data = data;
        this.#view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        this.#littleEndian = littleEndian;
        this.#varint = varint;
    }
    hasGzipHeader() {
        const header = this.#view.getUint16(0, false);
        return header === 0x1F8B;
    }
    hasZlibHeader() {
        const header = this.#view.getUint8(0);
        return header === 0x78;
    }
    hasBedrockLevelHeader(endian) {
        if (endian !== "little" || this.#data.byteLength < 8)
            return false;
        const byteLength = this.#view.getUint32(4, true);
        return byteLength === this.#data.byteLength - 8;
    }
    #allocate(byteLength) {
        if (this.#byteOffset + byteLength > this.#data.byteLength) {
            throw new Error("Ran out of bytes to read, unexpectedly reached the end of the buffer");
        }
    }
    async readRoot({ rootName, endian, compression, bedrockLevel, strict }) {
        if (compression !== null) {
            this.#data = await (0,_compression_js__WEBPACK_IMPORTED_MODULE_0__.decompress)(this.#data, compression);
            this.#view = new DataView(this.#data.buffer);
        }
        if (bedrockLevel) {
            // const version =
            this.#readUnsignedInt();
            this.#readUnsignedInt();
        }
        const type = this.#readTagType();
        if (type !== _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.LIST && type !== _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.COMPOUND) {
            throw new Error(`Expected an opening List or Compound tag at the start of the buffer, encountered tag type '${type}'`);
        }
        const rootNameV = typeof rootName === "string" || rootName ? this.#readString() : null;
        if (typeof rootName === "string" && rootNameV !== rootName) {
            throw new Error(`Expected root name '${rootName}', encountered '${rootNameV}'`);
        }
        const root = this.#readTag(type);
        if (strict && this.#data.byteLength > this.#byteOffset) {
            const remaining = this.#data.byteLength - this.#byteOffset;
            throw new Error(`Encountered unexpected End tag at byte offset ${this.#byteOffset}, ${remaining} unread bytes remaining`);
        }
        const result = new _format_js__WEBPACK_IMPORTED_MODULE_3__.NBTData(root, { rootName: rootNameV, endian, compression, bedrockLevel });
        if (!strict) {
            result.byteOffset = this.#byteOffset;
        }
        return result;
    }
    #readTag(type) {
        switch (type) {
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.END: {
                const remaining = this.#data.byteLength - this.#byteOffset;
                throw new Error(`Encountered unexpected End tag at byte offset ${this.#byteOffset}, ${remaining} unread bytes remaining`);
            }
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.BYTE: return this.#readByte();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.SHORT: return this.#readShort();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.INT: return this.#varint ? this.#readVarIntZigZag() : this.#readInt();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.LONG: return this.#varint ? this.#readVarLongZigZag() : this.#readLong();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.FLOAT: return this.#readFloat();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.DOUBLE: return this.#readDouble();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.BYTE_ARRAY: return this.#readByteArray();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.STRING: return this.#readString();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.LIST: return this.#readList();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.COMPOUND: return this.#readCompound();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.INT_ARRAY: return this.#readIntArray();
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.LONG_ARRAY: return this.#readLongArray();
            default: throw new Error(`Encountered unsupported tag type '${type}' at byte offset ${this.#byteOffset}`);
        }
    }
    #readTagType() {
        const type = this.#readUnsignedByte();
        if (!(0,_tag_js__WEBPACK_IMPORTED_MODULE_2__.isTagType)(type)) {
            throw new Error(`Encountered unsupported tag type '${type}' at byte offset ${this.#byteOffset}`);
        }
        return type;
    }
    #readUnsignedByte() {
        this.#allocate(1);
        const value = this.#view.getUint8(this.#byteOffset);
        this.#byteOffset += 1;
        return value;
    }
    #readByte(valueOf = false) {
        this.#allocate(1);
        const value = this.#view.getInt8(this.#byteOffset);
        this.#byteOffset += 1;
        return (valueOf) ? value : new _primitive_js__WEBPACK_IMPORTED_MODULE_4__.Int8(value);
    }
    #readUnsignedShort() {
        this.#allocate(2);
        const value = this.#view.getUint16(this.#byteOffset, this.#littleEndian);
        this.#byteOffset += 2;
        return value;
    }
    #readShort(valueOf = false) {
        this.#allocate(2);
        const value = this.#view.getInt16(this.#byteOffset, this.#littleEndian);
        this.#byteOffset += 2;
        return (valueOf) ? value : new _primitive_js__WEBPACK_IMPORTED_MODULE_4__.Int16(value);
    }
    #readUnsignedInt() {
        this.#allocate(4);
        const value = this.#view.getUint32(this.#byteOffset, this.#littleEndian);
        this.#byteOffset += 4;
        return value;
    }
    #readInt(valueOf = false) {
        this.#allocate(4);
        const value = this.#view.getInt32(this.#byteOffset, this.#littleEndian);
        this.#byteOffset += 4;
        return (valueOf) ? value : new _primitive_js__WEBPACK_IMPORTED_MODULE_4__.Int32(value);
    }
    #readVarInt() {
        let value = 0;
        let shift = 0;
        let byte;
        while (true) {
            byte = this.#readByte(true);
            value |= (byte & 0x7F) << shift;
            if ((byte & 0x80) === 0)
                break;
            shift += 7;
        }
        return value;
    }
    #readVarIntZigZag(valueOf = false) {
        let result = 0;
        let shift = 0;
        while (true) {
            this.#allocate(1);
            const byte = this.#readByte(true);
            result |= ((byte & 0x7F) << shift);
            if (!(byte & 0x80))
                break;
            shift += 7;
            if (shift > 63) {
                throw new Error(`VarInt size '${shift}' at byte offset ${this.#byteOffset} is too large`);
            }
        }
        const zigzag = ((((result << 63) >> 63) ^ result) >> 1) ^ (result & (1 << 63));
        return valueOf ? zigzag : new _primitive_js__WEBPACK_IMPORTED_MODULE_4__.Int32(zigzag);
    }
    #readLong() {
        this.#allocate(8);
        const value = this.#view.getBigInt64(this.#byteOffset, this.#littleEndian);
        this.#byteOffset += 8;
        return value;
    }
    #readVarLongZigZag() {
        let result = 0n;
        let shift = 0n;
        while (true) {
            this.#allocate(1);
            const byte = this.#readByte(true);
            result |= (BigInt(byte) & 0x7fn) << shift;
            if (!(byte & 0x80))
                break;
            shift += 7n;
            if (shift > 63n) {
                throw new Error(`VarLong size '${shift}' at byte offset ${this.#byteOffset} is too large`);
            }
        }
        const zigzag = (result >> 1n) ^ -(result & 1n);
        return zigzag;
    }
    #readFloat(valueOf = false) {
        this.#allocate(4);
        const value = this.#view.getFloat32(this.#byteOffset, this.#littleEndian);
        this.#byteOffset += 4;
        return (valueOf) ? value : new _primitive_js__WEBPACK_IMPORTED_MODULE_4__.Float32(value);
    }
    #readDouble() {
        this.#allocate(8);
        const value = this.#view.getFloat64(this.#byteOffset, this.#littleEndian);
        this.#byteOffset += 8;
        return value;
    }
    #readByteArray() {
        const length = this.#varint ? this.#readVarIntZigZag(true) : this.#readInt(true);
        this.#allocate(length);
        const value = new Int8Array(this.#data.subarray(this.#byteOffset, this.#byteOffset + length));
        this.#byteOffset += length;
        return value;
    }
    #readString() {
        const length = this.#varint ? this.#readVarInt() : this.#readUnsignedShort();
        this.#allocate(length);
        const value = this.#decoder.decode(this.#data.subarray(this.#byteOffset, this.#byteOffset + length));
        this.#byteOffset += length;
        return value;
    }
    #readList() {
        const type = this.#readTagType();
        const length = this.#varint ? this.#readVarIntZigZag(true) : this.#readInt(true);
        const value = [];
        Object.defineProperty(value, _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG_TYPE, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: type
        });
        for (let i = 0; i < length; i++) {
            const entry = this.#readTag(type);
            value.push(entry);
        }
        return value;
    }
    #readCompound() {
        const value = {};
        while (true) {
            const type = this.#readTagType();
            if (type === _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.END)
                break;
            const name = this.#readString();
            const entry = this.#readTag(type);
            value[name] = entry;
        }
        return value;
    }
    #readIntArray() {
        const length = this.#varint ? this.#readVarIntZigZag(true) : this.#readInt(true);
        const value = new Int32Array(length);
        for (const i in value) {
            const entry = this.#readInt(true);
            value[i] = entry;
        }
        return value;
    }
    #readLongArray() {
        const length = this.#varint ? this.#readVarIntZigZag(true) : this.#readInt(true);
        const value = new BigInt64Array(length);
        for (const i in value) {
            const entry = this.#readLong();
            value[i] = entry;
        }
        return value;
    }
}
//# sourceMappingURL=read.js.map

/***/ }),

/***/ "./node_modules/nbtify/dist/stringify.js":
/*!***********************************************!*\
  !*** ./node_modules/nbtify/dist/stringify.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stringify: () => (/* binding */ stringify)
/* harmony export */ });
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format.js */ "./node_modules/nbtify/dist/format.js");
/* harmony import */ var _tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tag.js */ "./node_modules/nbtify/dist/tag.js");


function stringify(data, { space = "" } = {}) {
    if (data instanceof _format_js__WEBPACK_IMPORTED_MODULE_0__.NBTData) {
        data = data.data;
    }
    if (typeof data !== "object" || data === null) {
        data;
        throw new TypeError("First parameter must be an object or array");
    }
    if (typeof space !== "string" && typeof space !== "number") {
        space;
        throw new TypeError("Space option must be a string or number");
    }
    space = typeof space === "number" ? " ".repeat(space) : space;
    const level = 1;
    return stringifyRoot(data, space, level);
}
function stringifyRoot(value, space, level) {
    const type = (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.getTagType)(value);
    if (type !== _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.LIST && type !== _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.COMPOUND) {
        throw new TypeError("Encountered unexpected Root tag type, must be either a List or Compound tag");
    }
    return stringifyTag(value, space, level);
}
function stringifyTag(value, space, level) {
    const type = (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.getTagType)(value);
    switch (type) {
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.BYTE: return stringifyByte(value);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.SHORT: return stringifyShort(value);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.INT: return stringifyInt(value);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.LONG: return stringifyLong(value);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.FLOAT: return stringifyFloat(value);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.DOUBLE: return stringifyDouble(value);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.BYTE_ARRAY: return stringifyByteArray(value);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.STRING: return stringifyString(value);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.LIST: return stringifyList(value, space, level);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.COMPOUND: return stringifyCompound(value, space, level);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.INT_ARRAY: return stringifyIntArray(value);
        case _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.LONG_ARRAY: return stringifyLongArray(value);
        default: throw new Error(`Encountered unsupported tag type '${type}'`);
    }
}
function stringifyByte(value) {
    return (typeof value === "boolean") ? `${value}` : `${value.valueOf()}b`;
}
function stringifyShort(value) {
    return `${value.valueOf()}s`;
}
function stringifyInt(value) {
    return `${value.valueOf()}`;
}
function stringifyLong(value) {
    return `${value}l`;
}
function stringifyFloat(value) {
    return `${value.valueOf()}${Number.isInteger(value.valueOf()) ? ".0" : ""}f`;
}
function stringifyDouble(value) {
    return `${value}${!Number.isInteger(value) || value.toExponential() === value.toString() ? "" : ".0"}d`;
}
function stringifyByteArray(value) {
    return `[B;${[...value].map(entry => stringifyByte(entry)).join()}]`;
}
function stringifyString(value) {
    const singleQuoteString = escapeString(value.replace(/['\\]/g, character => `\\${character}`));
    const doubleQuoteString = escapeString(value.replace(/["\\]/g, character => `\\${character}`));
    return (singleQuoteString.length < doubleQuoteString.length) ? `'${singleQuoteString}'` : `"${doubleQuoteString}"`;
}
function escapeString(value) {
    return value
        .replaceAll("\0", "\\0")
        .replaceAll("\b", "\\b")
        .replaceAll("\f", "\\f")
        .replaceAll("\n", "\\n")
        .replaceAll("\r", "\\r")
        .replaceAll("\t", "\\t");
}
function stringifyList(value, space, level) {
    value = value.filter(_tag_js__WEBPACK_IMPORTED_MODULE_1__.isTag);
    const fancy = (space !== "");
    const type = (value[0] !== undefined) ? (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.getTagType)(value[0]) : _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.END;
    const isIndentedList = fancy && new Set([_tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.BYTE_ARRAY, _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.LIST, _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.COMPOUND, _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.INT_ARRAY, _tag_js__WEBPACK_IMPORTED_MODULE_1__.TAG.LONG_ARRAY]).has(type);
    return `[${value.map(entry => `${isIndentedList ? `\n${space.repeat(level)}` : ""}${(() => {
        if ((0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.getTagType)(entry) !== type) {
            throw new TypeError("Encountered unexpected item type in array, all tags in a List tag must be of the same type");
        }
        const result = stringifyTag(entry, space, level + 1);
        return result;
    })()}`).join(`,${fancy && !isIndentedList ? " " : ""}`)}${isIndentedList ? `\n${space.repeat(level - 1)}` : ""}]`;
}
function stringifyCompound(value, space, level) {
    const fancy = (space !== "");
    return `{${Object.entries(value).filter((entry) => (0,_tag_js__WEBPACK_IMPORTED_MODULE_1__.isTag)(entry[1])).map(([key, value]) => `${fancy ? `\n${space.repeat(level)}` : ""}${/^[0-9a-z_\-.+]+$/i.test(key) ? key : stringifyString(key)}:${fancy ? " " : ""}${(() => {
        const result = stringifyTag(value, space, level + 1);
        return result;
    })()}`).join(",")}${fancy && Object.keys(value).length !== 0 ? `\n${space.repeat(level - 1)}` : ""}}`;
}
function stringifyIntArray(value) {
    return `[I;${[...value].map(entry => stringifyInt(entry)).join()}]`;
}
function stringifyLongArray(value) {
    return `[L;${[...value].map(entry => stringifyLong(entry)).join()}]`;
}
//# sourceMappingURL=stringify.js.map

/***/ }),

/***/ "./node_modules/nbtify/dist/tag.js":
/*!*****************************************!*\
  !*** ./node_modules/nbtify/dist/tag.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TAG: () => (/* binding */ TAG),
/* harmony export */   TAG_TYPE: () => (/* binding */ TAG_TYPE),
/* harmony export */   getTagType: () => (/* binding */ getTagType),
/* harmony export */   isTag: () => (/* binding */ isTag),
/* harmony export */   isTagType: () => (/* binding */ isTagType)
/* harmony export */ });
/* harmony import */ var _primitive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./primitive.js */ "./node_modules/nbtify/dist/primitive.js");

var TAG;
(function (TAG) {
    TAG[TAG["END"] = 0] = "END";
    TAG[TAG["BYTE"] = 1] = "BYTE";
    TAG[TAG["SHORT"] = 2] = "SHORT";
    TAG[TAG["INT"] = 3] = "INT";
    TAG[TAG["LONG"] = 4] = "LONG";
    TAG[TAG["FLOAT"] = 5] = "FLOAT";
    TAG[TAG["DOUBLE"] = 6] = "DOUBLE";
    TAG[TAG["BYTE_ARRAY"] = 7] = "BYTE_ARRAY";
    TAG[TAG["STRING"] = 8] = "STRING";
    TAG[TAG["LIST"] = 9] = "LIST";
    TAG[TAG["COMPOUND"] = 10] = "COMPOUND";
    TAG[TAG["INT_ARRAY"] = 11] = "INT_ARRAY";
    TAG[TAG["LONG_ARRAY"] = 12] = "LONG_ARRAY";
})(TAG || (TAG = {}));
Object.freeze(TAG);
const TAG_TYPE = Symbol("nbtify.tag.type");
function isTag(value) {
    return getTagType(value) !== null;
}
function isTagType(type) {
    return typeof type === "number" && type in TAG;
}
function getTagType(value) {
    switch (true) {
        case value instanceof _primitive_js__WEBPACK_IMPORTED_MODULE_0__.Int8:
        case typeof value === "boolean": return TAG.BYTE;
        case value instanceof _primitive_js__WEBPACK_IMPORTED_MODULE_0__.Int16: return TAG.SHORT;
        case value instanceof _primitive_js__WEBPACK_IMPORTED_MODULE_0__.Int32: return TAG.INT;
        case typeof value === "bigint": return TAG.LONG;
        case value instanceof _primitive_js__WEBPACK_IMPORTED_MODULE_0__.Float32: return TAG.FLOAT;
        case typeof value === "number": return TAG.DOUBLE;
        case value instanceof Int8Array:
        case value instanceof Uint8Array: return TAG.BYTE_ARRAY;
        case typeof value === "string": return TAG.STRING;
        case value instanceof Array: return TAG.LIST;
        case value instanceof Int32Array:
        case value instanceof Uint32Array: return TAG.INT_ARRAY;
        case value instanceof BigInt64Array:
        case value instanceof BigUint64Array: return TAG.LONG_ARRAY;
        case typeof value === "object" && value !== null: return TAG.COMPOUND;
        default: return null;
    }
}
//# sourceMappingURL=tag.js.map

/***/ }),

/***/ "./node_modules/nbtify/dist/write.js":
/*!*******************************************!*\
  !*** ./node_modules/nbtify/dist/write.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   write: () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var mutf_8__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mutf-8 */ "./node_modules/mutf-8/dist/index.mjs");
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format.js */ "./node_modules/nbtify/dist/format.js");
/* harmony import */ var _tag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tag.js */ "./node_modules/nbtify/dist/tag.js");
/* harmony import */ var _primitive_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./primitive.js */ "./node_modules/nbtify/dist/primitive.js");
/* harmony import */ var _compression_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compression.js */ "./node_modules/nbtify/dist/compression.js");





/**
 * Converts an NBT object into an NBT buffer. Accepts an endian type, compression format, and file headers to write the data with.
 *
 * If a format option isn't specified, the value of the equivalent property on the NBTData object will be used.
*/
async function write(data, options = {}) {
    data = new _format_js__WEBPACK_IMPORTED_MODULE_0__.NBTData(data, options);
    const { rootName, endian, compression, bedrockLevel } = data;
    if (typeof data !== "object" || data === null) {
        data;
        throw new TypeError("First parameter must be an object or array");
    }
    if (rootName !== undefined && typeof rootName !== "string" && rootName !== null) {
        rootName;
        throw new TypeError("Root Name option must be a string or null");
    }
    if (endian !== undefined && endian !== "big" && endian !== "little" && endian !== "little-varint") {
        endian;
        throw new TypeError("Endian option must be a valid endian type");
    }
    if (compression !== undefined && compression !== "deflate" && compression !== "deflate-raw" && compression !== "gzip" && compression !== null) {
        compression;
        throw new TypeError("Compression option must be a valid compression type");
    }
    if (bedrockLevel !== undefined && typeof bedrockLevel !== "boolean") {
        bedrockLevel;
        throw new TypeError("Bedrock Level option must be a boolean");
    }
    const writer = new NBTWriter(endian !== "big", endian === "little-varint");
    return writer.writeRoot(data);
}
class NBTWriter {
    #byteOffset = 0;
    #data = new Uint8Array(1024);
    #view = new DataView(this.#data.buffer);
    #littleEndian;
    #varint;
    #encoder = new mutf_8__WEBPACK_IMPORTED_MODULE_1__.MUtf8Encoder();
    constructor(littleEndian, varint) {
        this.#littleEndian = littleEndian;
        this.#varint = varint;
    }
    #allocate(byteLength) {
        const required = this.#byteOffset + byteLength;
        if (this.#data.byteLength >= required)
            return;
        let length = this.#data.byteLength;
        while (length < required) {
            length *= 2;
        }
        const data = new Uint8Array(length);
        data.set(this.#data, 0);
        // not sure this is really needed, keeping it just in case; freezer burn
        if (this.#byteOffset > this.#data.byteLength) {
            data.fill(0, byteLength, this.#byteOffset);
        }
        this.#data = data;
        this.#view = new DataView(data.buffer);
    }
    #trimmedEnd() {
        this.#allocate(0);
        return this.#data.slice(0, this.#byteOffset);
    }
    async writeRoot(data) {
        const { data: root, rootName, endian, compression, bedrockLevel } = data;
        const littleEndian = endian !== "big";
        const type = (0,_tag_js__WEBPACK_IMPORTED_MODULE_2__.getTagType)(root);
        if (type !== _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.LIST && type !== _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.COMPOUND) {
            throw new TypeError(`Encountered unexpected Root tag type '${type}', must be either a List or Compound tag`);
        }
        if (bedrockLevel) {
            this.#writeUnsignedInt(0);
            this.#writeUnsignedInt(0);
        }
        this.#writeTagType(type);
        if (rootName !== null)
            this.#writeString(rootName);
        this.#writeTag(root);
        if (bedrockLevel) {
            if (littleEndian !== true) {
                throw new TypeError("Endian option must be 'little' when the Bedrock Level flag is enabled");
            }
            if (!("StorageVersion" in root) || !(root["StorageVersion"] instanceof _primitive_js__WEBPACK_IMPORTED_MODULE_3__.Int32)) {
                throw new TypeError("Expected a 'StorageVersion' Int tag when Bedrock Level flag is enabled");
            }
            const version = root["StorageVersion"].valueOf();
            const byteLength = this.#byteOffset - 8;
            this.#view.setUint32(0, version, littleEndian);
            this.#view.setUint32(4, byteLength, littleEndian);
        }
        let result = this.#trimmedEnd();
        if (compression !== null) {
            result = await (0,_compression_js__WEBPACK_IMPORTED_MODULE_4__.compress)(result, compression);
        }
        return result;
    }
    #writeTag(value) {
        const type = (0,_tag_js__WEBPACK_IMPORTED_MODULE_2__.getTagType)(value);
        switch (type) {
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.BYTE: return this.#writeByte(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.SHORT: return this.#writeShort(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.INT: return this.#varint ? this.#writeVarIntZigZag(value) : this.#writeInt(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.LONG: return this.#varint ? this.#writeVarLongZigZag(value) : this.#writeLong(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.FLOAT: return this.#writeFloat(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.DOUBLE: return this.#writeDouble(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.BYTE_ARRAY: return this.#writeByteArray(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.STRING: return this.#writeString(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.LIST: return this.#writeList(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.COMPOUND: return this.#writeCompound(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.INT_ARRAY: return this.#writeIntArray(value);
            case _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.LONG_ARRAY: return this.#writeLongArray(value);
            default: throw new Error(`Encountered unsupported tag type '${type}'`);
        }
    }
    #writeTagType(type) {
        this.#writeUnsignedByte(type);
        return this;
    }
    #writeUnsignedByte(value) {
        this.#allocate(1);
        this.#view.setUint8(this.#byteOffset, value);
        this.#byteOffset += 1;
        return this;
    }
    #writeByte(value) {
        this.#allocate(1);
        this.#view.setInt8(this.#byteOffset, Number(value.valueOf()));
        this.#byteOffset += 1;
        return this;
    }
    #writeUnsignedShort(value) {
        this.#allocate(2);
        this.#view.setUint16(this.#byteOffset, value, this.#littleEndian);
        this.#byteOffset += 2;
        return this;
    }
    #writeShort(value) {
        this.#allocate(2);
        this.#view.setInt16(this.#byteOffset, value.valueOf(), this.#littleEndian);
        this.#byteOffset += 2;
        return this;
    }
    #writeUnsignedInt(value) {
        this.#allocate(4);
        this.#view.setUint32(this.#byteOffset, value, this.#littleEndian);
        this.#byteOffset += 4;
        return this;
    }
    #writeInt(value) {
        this.#allocate(4);
        this.#view.setInt32(this.#byteOffset, value.valueOf(), this.#littleEndian);
        this.#byteOffset += 4;
        return this;
    }
    #writeVarInt(value) {
        while (true) {
            let byte = value & 0x7F;
            value >>>= 7;
            if (value !== 0) {
                byte |= 0x80;
            }
            this.#writeByte(byte);
            if (value === 0)
                break;
        }
        return this;
    }
    #writeVarIntZigZag(value) {
        value = value.valueOf();
        value = (value << 1) ^ (value >> 31);
        while (value & ~0x7F) {
            const byte = (value & 0xFF) | 0x80;
            this.#writeByte(byte);
            value >>>= 7;
        }
        this.#writeByte(value);
        return this;
    }
    #writeLong(value) {
        this.#allocate(8);
        this.#view.setBigInt64(this.#byteOffset, value, this.#littleEndian);
        this.#byteOffset += 8;
        return this;
    }
    #writeVarLongZigZag(value) {
        value = (value << 1n) ^ (value >> 63n);
        while (value > 127n) {
            const byte = Number(value & 0xffn);
            this.#writeByte(byte | 0x80);
            value >>= 7n;
        }
        this.#writeByte(Number(value));
        return this;
    }
    #writeFloat(value) {
        this.#allocate(4);
        this.#view.setFloat32(this.#byteOffset, value.valueOf(), this.#littleEndian);
        this.#byteOffset += 4;
        return this;
    }
    #writeDouble(value) {
        this.#allocate(8);
        this.#view.setFloat64(this.#byteOffset, value, this.#littleEndian);
        this.#byteOffset += 8;
        return this;
    }
    #writeByteArray(value) {
        const { length } = value;
        this.#varint ? this.#writeVarIntZigZag(length) : this.#writeInt(length);
        this.#allocate(length);
        this.#data.set(value, this.#byteOffset);
        this.#byteOffset += length;
        return this;
    }
    #writeString(value) {
        const entry = this.#encoder.encode(value);
        const { length } = entry;
        this.#varint ? this.#writeVarInt(length) : this.#writeUnsignedShort(length);
        this.#allocate(length);
        this.#data.set(entry, this.#byteOffset);
        this.#byteOffset += length;
        return this;
    }
    #writeList(value) {
        let type = value[_tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG_TYPE];
        value = value.filter(_tag_js__WEBPACK_IMPORTED_MODULE_2__.isTag);
        type = type ?? (value[0] !== undefined ? (0,_tag_js__WEBPACK_IMPORTED_MODULE_2__.getTagType)(value[0]) : _tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.END);
        const { length } = value;
        this.#writeTagType(type);
        this.#varint ? this.#writeVarIntZigZag(length) : this.#writeInt(length);
        for (const entry of value) {
            if ((0,_tag_js__WEBPACK_IMPORTED_MODULE_2__.getTagType)(entry) !== type) {
                throw new TypeError("Encountered unexpected item type in array, all tags in a List tag must be of the same type");
            }
            this.#writeTag(entry);
        }
        return this;
    }
    #writeCompound(value) {
        for (const [name, entry] of Object.entries(value)) {
            if (entry === undefined)
                continue;
            const type = (0,_tag_js__WEBPACK_IMPORTED_MODULE_2__.getTagType)(entry);
            if (type === null)
                continue;
            this.#writeTagType(type);
            this.#writeString(name);
            this.#writeTag(entry);
        }
        this.#writeTagType(_tag_js__WEBPACK_IMPORTED_MODULE_2__.TAG.END);
        return this;
    }
    #writeIntArray(value) {
        const { length } = value;
        this.#varint ? this.#writeVarIntZigZag(length) : this.#writeInt(length);
        for (const entry of value) {
            this.#writeInt(entry);
        }
        return this;
    }
    #writeLongArray(value) {
        const { length } = value;
        this.#varint ? this.#writeVarIntZigZag(length) : this.#writeInt(length);
        for (const entry of value) {
            this.#writeLong(entry);
        }
        return this;
    }
}
//# sourceMappingURL=write.js.map

/***/ })

}]);